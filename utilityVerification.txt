curl --location 'https://api.etherscan.io/api' \
--form 'module="contract"' \
--form 'action="verifysourcecode"' \
--form 'apikey="API_KEY"' \
--form 'chainId="11155111"' \
--form 'codeformat="solidity-single-file"' \
--form 'sourceCode="// File: @openzeppelin/contracts/token/ERC20/IERC20.sol


// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.20;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when \`value\` tokens are moved from one account (\`from\`) to
     * another (\`to\`).
     *
     * Note that \`value\` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a \`spender\` for an \`owner\` is set by
     * a call to {approve}. \`value\` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the value of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the value of tokens owned by \`account\`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves a \`value\` amount of tokens from the caller'\''s account to \`to\`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 value) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that \`spender\` will be
     * allowed to spend on behalf of \`owner\` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets a \`value\` amount of tokens as the allowance of \`spender\` over the
     * caller'\''s tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender'\''s allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20\#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 value) external returns (bool);

    /**
     * @dev Moves a \`value\` amount of tokens from \`from\` to \`to\` using the
     * allowance mechanism. \`value\` is then deducted from the caller'\''s
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}

// File: @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol


// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)

pragma solidity ^0.8.20;


/**
 * @dev Interface for the optional metadata functions from the ERC20 standard.
 */
interface IERC20Metadata is IERC20 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view returns (uint8);
}

// File: @openzeppelin/contracts/utils/Context.sol


// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)

pragma solidity ^0.8.20;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }

    function _contextSuffixLength() internal view virtual returns (uint256) {
        return 0;
    }
}

// File: @openzeppelin/contracts/interfaces/draft-IERC6093.sol


// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)
pragma solidity ^0.8.20;

/**
 * @dev Standard ERC20 Errors
 * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.
 */
interface IERC20Errors {
    /**
     * @dev Indicates an error related to the current \`balance\` of a \`sender\`. Used in transfers.
     * @param sender Address whose tokens are being transferred.
     * @param balance Current balance for the interacting account.
     * @param needed Minimum amount required to perform a transfer.
     */
    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);

    /**
     * @dev Indicates a failure with the token \`sender\`. Used in transfers.
     * @param sender Address whose tokens are being transferred.
     */
    error ERC20InvalidSender(address sender);

    /**
     * @dev Indicates a failure with the token \`receiver\`. Used in transfers.
     * @param receiver Address to which tokens are being transferred.
     */
    error ERC20InvalidReceiver(address receiver);

    /**
     * @dev Indicates a failure with the \`spender\`’s \`allowance\`. Used in transfers.
     * @param spender Address that may be allowed to operate on tokens without being their owner.
     * @param allowance Amount of tokens a \`spender\` is allowed to operate with.
     * @param needed Minimum amount required to perform a transfer.
     */
    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);

    /**
     * @dev Indicates a failure with the \`approver\` of a token to be approved. Used in approvals.
     * @param approver Address initiating an approval operation.
     */
    error ERC20InvalidApprover(address approver);

    /**
     * @dev Indicates a failure with the \`spender\` to be approved. Used in approvals.
     * @param spender Address that may be allowed to operate on tokens without being their owner.
     */
    error ERC20InvalidSpender(address spender);
}

/**
 * @dev Standard ERC721 Errors
 * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.
 */
interface IERC721Errors {
    /**
     * @dev Indicates that an address can'\''t be an owner. For example, \`address(0)\` is a forbidden owner in EIP-20.
     * Used in balance queries.
     * @param owner Address of the current owner of a token.
     */
    error ERC721InvalidOwner(address owner);

    /**
     * @dev Indicates a \`tokenId\` whose \`owner\` is the zero address.
     * @param tokenId Identifier number of a token.
     */
    error ERC721NonexistentToken(uint256 tokenId);

    /**
     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.
     * @param sender Address whose tokens are being transferred.
     * @param tokenId Identifier number of a token.
     * @param owner Address of the current owner of a token.
     */
    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);

    /**
     * @dev Indicates a failure with the token \`sender\`. Used in transfers.
     * @param sender Address whose tokens are being transferred.
     */
    error ERC721InvalidSender(address sender);

    /**
     * @dev Indicates a failure with the token \`receiver\`. Used in transfers.
     * @param receiver Address to which tokens are being transferred.
     */
    error ERC721InvalidReceiver(address receiver);

    /**
     * @dev Indicates a failure with the \`operator\`’s approval. Used in transfers.
     * @param operator Address that may be allowed to operate on tokens without being their owner.
     * @param tokenId Identifier number of a token.
     */
    error ERC721InsufficientApproval(address operator, uint256 tokenId);

    /**
     * @dev Indicates a failure with the \`approver\` of a token to be approved. Used in approvals.
     * @param approver Address initiating an approval operation.
     */
    error ERC721InvalidApprover(address approver);

    /**
     * @dev Indicates a failure with the \`operator\` to be approved. Used in approvals.
     * @param operator Address that may be allowed to operate on tokens without being their owner.
     */
    error ERC721InvalidOperator(address operator);
}

/**
 * @dev Standard ERC1155 Errors
 * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.
 */
interface IERC1155Errors {
    /**
     * @dev Indicates an error related to the current \`balance\` of a \`sender\`. Used in transfers.
     * @param sender Address whose tokens are being transferred.
     * @param balance Current balance for the interacting account.
     * @param needed Minimum amount required to perform a transfer.
     * @param tokenId Identifier number of a token.
     */
    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);

    /**
     * @dev Indicates a failure with the token \`sender\`. Used in transfers.
     * @param sender Address whose tokens are being transferred.
     */
    error ERC1155InvalidSender(address sender);

    /**
     * @dev Indicates a failure with the token \`receiver\`. Used in transfers.
     * @param receiver Address to which tokens are being transferred.
     */
    error ERC1155InvalidReceiver(address receiver);

    /**
     * @dev Indicates a failure with the \`operator\`’s approval. Used in transfers.
     * @param operator Address that may be allowed to operate on tokens without being their owner.
     * @param owner Address of the current owner of a token.
     */
    error ERC1155MissingApprovalForAll(address operator, address owner);

    /**
     * @dev Indicates a failure with the \`approver\` of a token to be approved. Used in approvals.
     * @param approver Address initiating an approval operation.
     */
    error ERC1155InvalidApprover(address approver);

    /**
     * @dev Indicates a failure with the \`operator\` to be approved. Used in approvals.
     * @param operator Address that may be allowed to operate on tokens without being their owner.
     */
    error ERC1155InvalidOperator(address operator);

    /**
     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.
     * Used in batch transfers.
     * @param idsLength Length of the array of token identifiers
     * @param valuesLength Length of the array of token amounts
     */
    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);
}

// File: @openzeppelin/contracts/token/ERC20/ERC20.sol


// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)

pragma solidity ^0.8.20;





/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * The default value of {decimals} is 18. To change this, you should override
 * this function so it returns a different value.
 *
 * We have followed general OpenZeppelin Contracts guidelines: functions revert
 * instead returning \`false\` on failure. This behavior is nonetheless
 * conventional and does not conflict with the expectations of ERC20
 * applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn'\''t required by the specification.
 */
abstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {
    mapping(address account => uint256) private _balances;

    mapping(address account => mapping(address spender => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;

    /**
     * @dev Sets the values for {name} and {symbol}.
     *
     * All two of these values are immutable: they can only be set once during
     * construction.
     */
    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view virtual returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view virtual returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if \`decimals\` equals \`2\`, a balance of \`505\` tokens should
     * be displayed to a user as \`5.05\` (\`505 / 10 ** 2\`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the default value returned by this function, unless
     * it'\''s overridden.
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view virtual returns (uint8) {
        return 18;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view virtual returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view virtual returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - \`to\` cannot be the zero address.
     * - the caller must have a balance of at least \`value\`.
     */
    function transfer(address to, uint256 value) public virtual returns (bool) {
        address owner = _msgSender();
        _transfer(owner, to, value);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * NOTE: If \`value\` is the maximum \`uint256\`, the allowance is not updated on
     * \`transferFrom\`. This is semantically equivalent to an infinite approval.
     *
     * Requirements:
     *
     * - \`spender\` cannot be the zero address.
     */
    function approve(address spender, uint256 value) public virtual returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, value);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * NOTE: Does not update the allowance if the current allowance
     * is the maximum \`uint256\`.
     *
     * Requirements:
     *
     * - \`from\` and \`to\` cannot be the zero address.
     * - \`from\` must have a balance of at least \`value\`.
     * - the caller must have allowance for \`\`from\`\`'\''s tokens of at least
     * \`value\`.
     */
    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {
        address spender = _msgSender();
        _spendAllowance(from, spender, value);
        _transfer(from, to, value);
        return true;
    }

    /**
     * @dev Moves a \`value\` amount of tokens from \`from\` to \`to\`.
     *
     * This internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * NOTE: This function is not virtual, {_update} should be overridden instead.
     */
    function _transfer(address from, address to, uint256 value) internal {
        if (from == address(0)) {
            revert ERC20InvalidSender(address(0));
        }
        if (to == address(0)) {
            revert ERC20InvalidReceiver(address(0));
        }
        _update(from, to, value);
    }

    /**
     * @dev Transfers a \`value\` amount of tokens from \`from\` to \`to\`, or alternatively mints (or burns) if \`from\`
     * (or \`to\`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding
     * this function.
     *
     * Emits a {Transfer} event.
     */
    function _update(address from, address to, uint256 value) internal virtual {
        if (from == address(0)) {
            // Overflow check required: The rest of the code assumes that totalSupply never overflows
            _totalSupply += value;
        } else {
            uint256 fromBalance = _balances[from];
            if (fromBalance < value) {
                revert ERC20InsufficientBalance(from, fromBalance, value);
            }
            unchecked {
                // Overflow not possible: value <= fromBalance <= totalSupply.
                _balances[from] = fromBalance - value;
            }
        }

        if (to == address(0)) {
            unchecked {
                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.
                _totalSupply -= value;
            }
        } else {
            unchecked {
                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.
                _balances[to] += value;
            }
        }

        emit Transfer(from, to, value);
    }

    /**
     * @dev Creates a \`value\` amount of tokens and assigns them to \`account\`, by transferring it from address(0).
     * Relies on the \`_update\` mechanism
     *
     * Emits a {Transfer} event with \`from\` set to the zero address.
     *
     * NOTE: This function is not virtual, {_update} should be overridden instead.
     */
    function _mint(address account, uint256 value) internal {
        if (account == address(0)) {
            revert ERC20InvalidReceiver(address(0));
        }
        _update(address(0), account, value);
    }

    /**
     * @dev Destroys a \`value\` amount of tokens from \`account\`, lowering the total supply.
     * Relies on the \`_update\` mechanism.
     *
     * Emits a {Transfer} event with \`to\` set to the zero address.
     *
     * NOTE: This function is not virtual, {_update} should be overridden instead
     */
    function _burn(address account, uint256 value) internal {
        if (account == address(0)) {
            revert ERC20InvalidSender(address(0));
        }
        _update(account, address(0), value);
    }

    /**
     * @dev Sets \`value\` as the allowance of \`spender\` over the \`owner\` s tokens.
     *
     * This internal function is equivalent to \`approve\`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - \`owner\` cannot be the zero address.
     * - \`spender\` cannot be the zero address.
     *
     * Overrides to this logic should be done to the variant with an additional \`bool emitEvent\` argument.
     */
    function _approve(address owner, address spender, uint256 value) internal {
        _approve(owner, spender, value, true);
    }

    /**
     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.
     *
     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by
     * \`_spendAllowance\` during the \`transferFrom\` operation set the flag to false. This saves gas by not emitting any
     * \`Approval\` event during \`transferFrom\` operations.
     *
     * Anyone who wishes to continue emitting \`Approval\` events on the\`transferFrom\` operation can force the flag to
     * true using the following override:
     * \`\`\`
     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {
     *     super._approve(owner, spender, value, true);
     * }
     * \`\`\`
     *
     * Requirements are the same as {_approve}.
     */
    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {
        if (owner == address(0)) {
            revert ERC20InvalidApprover(address(0));
        }
        if (spender == address(0)) {
            revert ERC20InvalidSpender(address(0));
        }
        _allowances[owner][spender] = value;
        if (emitEvent) {
            emit Approval(owner, spender, value);
        }
    }

    /**
     * @dev Updates \`owner\` s allowance for \`spender\` based on spent \`value\`.
     *
     * Does not update the allowance value in case of infinite allowance.
     * Revert if not enough allowance is available.
     *
     * Does not emit an {Approval} event.
     */
    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {
        uint256 currentAllowance = allowance(owner, spender);
        if (currentAllowance \!= type(uint256).max) {
            if (currentAllowance < value) {
                revert ERC20InsufficientAllowance(spender, currentAllowance, value);
            }
            unchecked {
                _approve(owner, spender, currentAllowance - value, false);
            }
        }
    }
}

// File: @openzeppelin/contracts/access/Ownable.sol


// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)

pragma solidity ^0.8.20;


/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * The initial owner is set to the address provided by the deployer. This can
 * later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * \`onlyOwner\`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    /**
     * @dev The caller account is not authorized to perform an operation.
     */
    error OwnableUnauthorizedAccount(address account);

    /**
     * @dev The owner is not a valid owner account. (eg. \`address(0)\`)
     */
    error OwnableInvalidOwner(address owner);

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.
     */
    constructor(address initialOwner) {
        if (initialOwner == address(0)) {
            revert OwnableInvalidOwner(address(0));
        }
        _transferOwnership(initialOwner);
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        if (owner() \!= _msgSender()) {
            revert OwnableUnauthorizedAccount(_msgSender());
        }
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * \`onlyOwner\` functions. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby disabling any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (\`newOwner\`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        if (newOwner == address(0)) {
            revert OwnableInvalidOwner(address(0));
        }
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (\`newOwner\`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

// File: @openzeppelin/contracts/utils/Pausable.sol


// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)

pragma solidity ^0.8.20;


/**
 * @dev Contract module which allows children to implement an emergency stop
 * mechanism that can be triggered by an authorized account.
 *
 * This module is used through inheritance. It will make available the
 * modifiers \`whenNotPaused\` and \`whenPaused\`, which can be applied to
 * the functions of your contract. Note that they will not be pausable by
 * simply including this module, only once the modifiers are put in place.
 */
abstract contract Pausable is Context {
    bool private _paused;

    /**
     * @dev Emitted when the pause is triggered by \`account\`.
     */
    event Paused(address account);

    /**
     * @dev Emitted when the pause is lifted by \`account\`.
     */
    event Unpaused(address account);

    /**
     * @dev The operation failed because the contract is paused.
     */
    error EnforcedPause();

    /**
     * @dev The operation failed because the contract is not paused.
     */
    error ExpectedPause();

    /**
     * @dev Initializes the contract in unpaused state.
     */
    constructor() {
        _paused = false;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     *
     * Requirements:
     *
     * - The contract must not be paused.
     */
    modifier whenNotPaused() {
        _requireNotPaused();
        _;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is paused.
     *
     * Requirements:
     *
     * - The contract must be paused.
     */
    modifier whenPaused() {
        _requirePaused();
        _;
    }

    /**
     * @dev Returns true if the contract is paused, and false otherwise.
     */
    function paused() public view virtual returns (bool) {
        return _paused;
    }

    /**
     * @dev Throws if the contract is paused.
     */
    function _requireNotPaused() internal view virtual {
        if (paused()) {
            revert EnforcedPause();
        }
    }

    /**
     * @dev Throws if the contract is not paused.
     */
    function _requirePaused() internal view virtual {
        if (\!paused()) {
            revert ExpectedPause();
        }
    }

    /**
     * @dev Triggers stopped state.
     *
     * Requirements:
     *
     * - The contract must not be paused.
     */
    function _pause() internal virtual whenNotPaused {
        _paused = true;
        emit Paused(_msgSender());
    }

    /**
     * @dev Returns to normal state.
     *
     * Requirements:
     *
     * - The contract must be paused.
     */
    function _unpause() internal virtual whenPaused {
        _paused = false;
        emit Unpaused(_msgSender());
    }
}

// File: @openzeppelin/contracts/utils/ReentrancyGuard.sol


// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)

pragma solidity ^0.8.20;

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from \`ReentrancyGuard\` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single \`nonReentrant\` guard, functions marked as
 * \`nonReentrant\` may not call one another. This can be worked around by making
 * those functions \`private\`, and then adding \`external\` \`nonReentrant\` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot'\''s contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler'\''s defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction'\''s gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant NOT_ENTERED = 1;
    uint256 private constant ENTERED = 2;

    uint256 private _status;

    /**
     * @dev Unauthorized reentrant call.
     */
    error ReentrancyGuardReentrantCall();

    constructor() {
        _status = NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a \`nonReentrant\` function from another \`nonReentrant\`
     * function is not supported. It is possible to prevent this from happening
     * by making the \`nonReentrant\` function external, and making it call a
     * \`private\` function that does the actual work.
     */
    modifier nonReentrant() {
        _nonReentrantBefore();
        _;
        _nonReentrantAfter();
    }

    function _nonReentrantBefore() private {
        // On the first call to nonReentrant, _status will be NOT_ENTERED
        if (_status == ENTERED) {
            revert ReentrancyGuardReentrantCall();
        }

        // Any calls to nonReentrant after this point will fail
        _status = ENTERED;
    }

    function _nonReentrantAfter() private {
        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = NOT_ENTERED;
    }

    /**
     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a
     * \`nonReentrant\` function in the call stack.
     */
    function _reentrancyGuardEntered() internal view returns (bool) {
        return _status == ENTERED;
    }
}

// File: contracts/Utility/UT5.sol

//SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;





contract UTtokenV2 is ERC20, Ownable, Pausable, ReentrancyGuard {
    mapping(address => bool) public blackListedAddress;
    mapping(address => uint256) public restrictedBalances;
    mapping(address => uint256) public restrictedUntil;

    mapping(address => mapping(uint256 => StakeInfo)) public userStakes; // User -> StakeId -> StakeInfo
    mapping(address => uint256) public nextStakeId; // Tracks the next stake ID for each user

    uint16 public txnTaxRateBasisPoints;
    address public txnTaxWallet;
    uint8 private _decimals;
    // IUniswapV2Router02 public uniswapRouter;

    struct smartContractActions {
        bool canMint;
        bool canBurn;
        bool canPause;
        bool canBlacklist;
        bool canChangeOwner;
        bool canTxTax;
        bool canBuyBack;
        bool canStake;
    }
    struct ConditionalTokens {
        uint256 incentiveId;
        uint256 _amt;
        uint256 _duration;
        uint256 _burningTime;
        bool _isBurnt;
        // bool _isSubscribed;
    }

    mapping(address => uint256) public incentiveId;
    mapping(address => ConditionalTokens[]) public conditionalTokens;
    mapping(address => uint256) public frozenTokens;

    struct StakeInfo {
        uint256 id;
        uint256 amount;
        uint256 lockUntil;
        uint256 startTime;
        bool isActive;
        bool isRewarded;
    }
    struct TokenRewardRate {
        uint8 months;
        uint32 rewardRate;
    }

    TokenRewardRate[] public rewardRates;

    smartContractActions public actions;
    event LogApproval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );

    event TokensStaked(
        address indexed user,
        uint256 stakeId,
        uint256 amount,
        uint256 startTime,
        uint256 lockUntil
    );

    event TokensUnstaked(
        address indexed user,
        uint256 stakeId,
        uint256 amount,
        uint256 unstakeTime
    );

    event LogTotalSupply(uint256 totalSupply, uint256 decimals);

    modifier canMintModifier() {
        require(
            actions.canMint,
            \"Minting Functionality is not enabled in this smart contract\!\"
        );
        _;
    }

    modifier canBurnModifier() {
        require(
            actions.canBurn,
            \"Burning Functionality is not enabled in this smart contract\!\"
        );
        _;
    }

    modifier canPauseModifier() {
        require(
            actions.canPause,
            \"Pause/Unpause Functionality is not enabled in this smart contract\!\"
        );
        _;
    }

    modifier canBlacklistModifier() {
        require(
            actions.canBlacklist,
            \"Blacklist Address Functionality is not enabled in this smart contract\!\"
        );
        _;
    }

    modifier canChangeOwnerModifier() {
        require(
            actions.canChangeOwner,
            \"Change Owner Functionality is not enabled in this smart contract\!\"
        );
        _;
    }

    modifier canBuyBackModifier() {
        require(
            actions.canBuyBack,
            \"Buyback Token Functionality is not enabled in this smart contract\!\"
        );
        _;
    }

    modifier canStakeModifier() {
        require(
            actions.canStake,
            \"Staking reward Functionality is not enabled in this smart contract\!\"
        );
        _;
    }

    modifier canTxTaxModifier() {
        require(
            actions.canTxTax,
            \"Txn Tax Functionality is not enabled in this smart contract\!\"
        );
        _;
    }
    modifier isBlackListed() {
        require(\!blackListedAddress[msg.sender], \"User is blacklisted\!\");
        _;
    }

    constructor(
        uint256 preMintValue,
        string memory _tokenTicker,
        string memory _tokenName,
        address _initialAddress,
        smartContractActions memory _actions,
        uint16 _txnTaxRateBasisPoints,
        address _txnTaxWallet,
        uint8 decimals_,
        TokenRewardRate[] memory _rewardRates
    ) ERC20(_tokenName, _tokenTicker) Ownable(_initialAddress) {
        _decimals = decimals_;
        initializeToken(preMintValue);
        initializeTaxSettings(_txnTaxRateBasisPoints, _txnTaxWallet);
        initializeFeatures(_actions);
        for (uint256 i = 0; i < _rewardRates.length; i++) {
            rewardRates.push(_rewardRates[i]);
        }
    }

    function conditionalTokenTransfer(
        address _user,
        uint256 _amt,
        uint8 _months
    ) public {
        require(_amt > 0, \"Transfer amount must be greater than zero.\");
        require(_months > 0, \"Months must be greater than zero.\");
        require(_user \!= address(0), \"Invalid user address.\");
        require(
            balanceOf(msg.sender) >= _amt,
            \"Insufficient balance for transfer.\"
        );

        ConditionalTokens[] storage tokens = conditionalTokens[_user];

        uint256 id = incentiveId[_user];

        ConditionalTokens memory _tokenInfo = ConditionalTokens(
            id,
            _amt,
            uint256(_months),
            block.timestamp + (_months * 30 days),
            false
        );

        incentiveId[_user]++;
        tokens.push(_tokenInfo);

        frozenTokens[_user] += _amt;

        _transfer(msg.sender, _user, _amt);
    }

    function initializeToken(uint256 preMintValue) internal {
        uint256 convertedValue = convertDecimals(preMintValue);
        _mint(address(this), convertedValue);
        approve(owner(), convertedValue);
        emit LogTotalSupply(totalSupply(), decimals());
    }

    function decimals() public view virtual override returns (uint8) {
        return _decimals;
    }

    function setBasisPoints(uint8 percentage) public pure returns (uint256) {
        require(percentage > 0, \"Percentage must be greater than 0\");
        // Convert the percentage to basis points (1% = 1000 basis points)
        uint256 basisPoints = uint256(percentage) * 1000;
        return basisPoints;
    }

    function initializeTaxSettings(uint16 _txnTaxRate, address _txnTaxWallet)
        internal
    {
        require(_txnTaxWallet \!= address(0), \"TxnTax Wallet can'\''t be empty\");
        require(_txnTaxRate > 0, \"Transaction rate must be grater than 0\");
        txnTaxWallet = _txnTaxWallet;
        txnTaxRateBasisPoints = _txnTaxRate;
    }

    function withdrawAll() external {
        StakeInfo[] memory tempStakes = isEligible(msg.sender);
        require(tempStakes.length > 0, \"No stakes to withdraw\");

        for (uint256 i = 0; i < tempStakes.length; ) {
            unStakeById(tempStakes[i].id);
            unchecked {
                i++;
            }
        }
    }

    function isEligible(address _staker)
        public
        view
        returns (StakeInfo[] memory eligibleStakes)
    {
        uint256 stakeCount = nextStakeId[_staker];
        uint256 index = 0;

        // Create a temporary array with a size equal to the total stake count
        StakeInfo[] memory tempStakes = new StakeInfo[](stakeCount);

        for (uint256 i = 0; i < stakeCount; ) {
            StakeInfo memory _stake = userStakes[_staker][i];
            if (
                block.timestamp >= _stake.lockUntil &&
                \!_stake.isRewarded &&
                _stake.amount > 0
            ) {
                tempStakes[index] = _stake;
                index++;
            }
            unchecked {
                i++;
            }
        }

        // Create the final array with the exact size of eligible stakes
        eligibleStakes = new StakeInfo[](index);
        for (uint256 i = 0; i < index; ) {
            eligibleStakes[i] = tempStakes[i];
            unchecked {
                i++;
            } // Use unchecked to save gas
        }
    }

    function initializeFeatures(smartContractActions memory _actions) private {
        actions.canStake = _actions.canStake;
        actions.canBurn = _actions.canBurn;
        actions.canMint = _actions.canMint;
        actions.canPause = _actions.canPause;
        actions.canBlacklist = _actions.canBlacklist;
        actions.canChangeOwner = _actions.canChangeOwner;
        actions.canTxTax = _actions.canTxTax;
        actions.canBuyBack = _actions.canBuyBack;
    }

    function pauseTokenTransfers() public canPauseModifier onlyOwner {
        require(\!paused(), \"Contract is already paused.\");
        _pause();
    }

    function unPauseTokenTransfers() public canPauseModifier onlyOwner {
        require(paused(), \"Contract is not paused.\");
        _unpause();
    }

    function transferOwnership(address newOwner)
        public
        override
        canChangeOwnerModifier
        onlyOwner
    {
        _transferOwnership(newOwner);
    }

    function convertDecimals(uint256 _amount) private view returns (uint256) {
        return _amount * 10**decimals();
    }

    function transferToOwner(uint256 transferAmount) public onlyOwner {
        _transfer(address(this), msg.sender, transferAmount);
    }

    function transferTokensToUser(
        address user,
        uint256 amount,
        uint256 lockDurationInMonths
    ) public onlyOwner whenNotPaused {
        require(
            balanceOf(address(this)) >= amount,
            \"Contract does not have enough tokens\"
        );
        require(\!blackListedAddress[user], \"User is blacklisted\");
        require(amount > 0, \"Transfer amount must be greater than zero\");

        _transfer(address(this), user, amount);

        // Restrict tokens until the specified lock duration
        restrictedBalances[user] += amount;
        restrictedUntil[user] =
            block.timestamp +
            (lockDurationInMonths * 30 days);
    }

    function transferUnrestrictedTokens(address user, uint256 amount)
        public
        onlyOwner
        whenNotPaused
    {
        require(
            balanceOf(address(this)) >= amount,
            \"Contract does not have enough tokens\"
        );
        require(\!blackListedAddress[user], \"User is blacklisted\");
        require(amount > 0, \"Transfer amount must be greater than zero\");

        _transfer(address(this), user, amount);
    }

    function burnExpiredTokens(address user) public {
        if (
            restrictedBalances[user] > 0 &&
            block.timestamp > restrictedUntil[user]
        ) {
            uint256 amountToBurn = restrictedBalances[user];
            restrictedBalances[user] = 0;
            _burn(user, amountToBurn);
        }

        // Iterate through the conditional tokens array and burn expired tokens
        ConditionalTokens[] storage userTokens = conditionalTokens[user];
        uint256 length = userTokens.length;

        for (uint256 i = 0; i < length; ) {
            if (
                block.timestamp > userTokens[i]._burningTime &&
                \!userTokens[i]._isBurnt
            ) {
                uint256 amountToBurn = userTokens[i]._amt;
                userTokens[i]._amt = 0;
                frozenTokens[user] -= amountToBurn;
                userTokens[i]._isBurnt = true;
                _burn(user, amountToBurn);
            }
            unchecked {
                i++;
            }
        }
    }

    function transfer(address recipient, uint256 amount)
        public
        override
        returns (bool)
    {
        // Burn expired restricted tokens before allowing transfer
        burnExpiredTokens(msg.sender);

        uint256 actualBal = balanceOf(msg.sender) - frozenTokens[msg.sender];
        // Calculate unrestricted balance
        uint256 unrestrictedBalance = actualBal -
            restrictedBalances[msg.sender];

        require(
            amount <= unrestrictedBalance,
            \"Transfer exceeds unrestricted token balance\"
        );

        if (actions.canTxTax) {
            uint256 taxAmount = (amount * txnTaxRateBasisPoints) / (100 * 1000);
            uint256 netAmount = amount - taxAmount;

            // Transfer tax to tax wallet
            super.transfer(txnTaxWallet, taxAmount);
            // Transfer remaining tokens to the recipient
            return super.transfer(recipient, netAmount);
        } else {
            return super.transfer(recipient, amount);
        }
    }

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public override returns (bool) {
        // Burn expired restricted tokens before allowing transfer
        burnExpiredTokens(sender);

        // Calculate unrestricted balance
        uint256 unrestrictedBalance = balanceOf(sender) -
            restrictedBalances[sender];

        require(
            amount <= unrestrictedBalance,
            \"Transfer exceeds unrestricted token balance\"
        );

        if (actions.canTxTax) {
            uint256 taxAmount = (amount * txnTaxRateBasisPoints) / (100 * 1000);
            uint256 netAmount = amount - taxAmount;

            // Transfer tax to tax wallet
            super.transferFrom(sender, txnTaxWallet, taxAmount);
            // Transfer remaining tokens to the recipient
            return super.transferFrom(sender, recipient, netAmount);
        } else {
            return super.transferFrom(sender, recipient, amount);
        }
    }

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount,
        bool burn
    ) public returns (bool) {
        // Burn expired restricted tokens before allowing transfer
        if (burn) {
            burnExpiredTokens(sender);
        }

        // Calculate unrestricted balance
        uint256 unrestrictedBalance = balanceOf(sender) -
            restrictedBalances[sender];

        require(
            amount <= unrestrictedBalance,
            \"Transfer exceeds unrestricted token balance\"
        );

        if (actions.canTxTax) {
            uint256 taxAmount = (amount * txnTaxRateBasisPoints) / (100 * 1000);
            uint256 netAmount = amount - taxAmount;

            // Transfer tax to tax wallet
            super.transferFrom(sender, txnTaxWallet, taxAmount);
            // Transfer remaining tokens to the recipient
            return super.transferFrom(sender, recipient, netAmount);
        } else {
            return super.transferFrom(sender, recipient, amount);
        }
    }

    function whiteListUser(address _user)
        public
        canBlacklistModifier
        onlyOwner
        whenNotPaused
    {
        require(blackListedAddress[_user], \"User Address is not blacklisted\");
        blackListedAddress[_user] = false;
    }

    function setTxnTaxRateBasisPoints(uint8 _rateValue)
        public
        canTxTaxModifier
        onlyOwner
        whenNotPaused
    {
        require(_rateValue > 0, \"Rate must be grater than 0\");
        txnTaxRateBasisPoints = _rateValue;
    }

    function setTxnTaxWallet(address _txnTaxWallet)
        public
        canTxTaxModifier
        onlyOwner
        whenNotPaused
    {
        require(_txnTaxWallet \!= address(0), \"Txn tax wallet can'\''t be empty\");
        txnTaxWallet = _txnTaxWallet;
    }

    function mintSupply(uint256 _amount)
        public
        canMintModifier
        onlyOwner
        whenNotPaused
    {
        require(_amount > 0, \"Mint more than Zero\");
        _mint(address(this), convertDecimals(_amount));
    }

    function blackListUsers(address[] calldata _users)
        public
        canBlacklistModifier
        onlyOwner
        whenNotPaused
    {
        for (uint256 i = 0; i < _users.length; i++) {
            require(
                \!blackListedAddress[_users[i]],
                \"User Address is already blacklisted\"
            );
            blackListedAddress[_users[i]] = true;
        }
    }

    function whiteListUsers(address[] calldata _users)
        public
        canBlacklistModifier
        onlyOwner
        whenNotPaused
    {
        for (uint256 i = 0; i < _users.length; i++) {
            require(
                blackListedAddress[_users[i]],
                \"User Address is not blacklisted\"
            );
            blackListedAddress[_users[i]] = false;
        }
    }

    function burnSupply(uint256 _amount)
        public
        canBurnModifier
        onlyOwner
        whenNotPaused
    {
        require(_amount > 0, \"Burn more than Zero\");
        _burn(address(this), convertDecimals(_amount));
    }

    function stake(uint256 _amount, uint256 _lockDuration)
        external
        canStakeModifier
        nonReentrant
        whenNotPaused
        isBlackListed
    {
        require(_amount > 0, \"Amount must be greater than zero\");
        require(
            _lockDuration >= 1 && _lockDuration <= 24,
            \"Lock period must be between 1 and 24 months\"
        );
        uint256 stakeId = nextStakeId[msg.sender];
        nextStakeId[msg.sender]++;
        userStakes[msg.sender][stakeId] = StakeInfo({
            id: stakeId,
            amount: _amount,
            startTime: block.timestamp,
            lockUntil: block.timestamp + (_lockDuration * 30 days), // add 30 days
            isActive: true,
            isRewarded: false
        });

        _transfer(msg.sender, address(this), _amount);
        emit TokensStaked(
            msg.sender,
            stakeId,
            _amount,
            block.timestamp,
            block.timestamp + (_lockDuration * 30 days)
        );
    }

    function unStakeById(uint256 _stakeId)
        public
        canStakeModifier
        nonReentrant
        whenNotPaused
        isBlackListed
    {
        require(_stakeId < nextStakeId[msg.sender], \"Invalid stake ID\");

        StakeInfo storage userStake = userStakes[msg.sender][_stakeId];

        require(\!userStake.isRewarded, \"Stake has already been rewarded\");
        require(userStake.amount > 0, \"No staked amount available to unstake\");
        require(
            block.timestamp >= userStake.lockUntil,
            \"Stake is still locked\"
        );

        uint256 unstakeAmount = userStake.amount;
        uint256 rewardAmt = stakeRewardCal(
            userStake.amount,
            userStake.startTime,
            block.timestamp
        );

        // Mark as rewarded and inactive
        userStake.isActive = false;
        userStake.isRewarded = true;

        // Transfer tokens back to the user
        _transfer(address(this), msg.sender, unstakeAmount + rewardAmt);
    }

    function unstake(uint256 _amount)
        external
        canStakeModifier
        nonReentrant
        whenNotPaused
        isBlackListed
    {
        require(_amount > 0, \"Amount must be greater than zero\");
        uint256 remainingAmountToUnstake = _amount;
        uint256 totalUnstakedAmount = 0;
        uint256 stakeCount = nextStakeId[msg.sender];

        for (uint256 i = stakeCount; i > 0; i--) {
            StakeInfo storage userStake = userStakes[msg.sender][i - 1];

            // Only consider active and unrewarded stakes
            if (\!userStake.isRewarded) {
                if (userStake.amount <= remainingAmountToUnstake) {
                    remainingAmountToUnstake -= userStake.amount;
                    totalUnstakedAmount += userStake.amount;
                    userStake.amount = 0;
                    userStake.isActive = false;
                } else {
                    totalUnstakedAmount += remainingAmountToUnstake;
                    userStake.amount -= remainingAmountToUnstake;
                    remainingAmountToUnstake = 0;
                }

                // Exit loop if the required amount is fully unstaked
                if (remainingAmountToUnstake == 0) {
                    break;
                }
            }
        }

        require(
            totalUnstakedAmount == _amount,
            \"Not enough staked balance to unstake the requested amount\"
        );

        // Transfer tokens back to the user
        _transfer(address(this), msg.sender, totalUnstakedAmount);

        // emit TokensUnstaked(msg.sender, _amount, block.timestamp);
    }

    function burnFrom(address _user, uint256 _amount) public onlyOwner {
        uint256 currentAllowance = allowance(_user, owner()); //100
        require(currentAllowance >= _amount, \"Burn amount exceeds allowance\");
        uint256 userBalance = balanceOf(_user);
        if (userBalance == 0) {
            _approve(_user, owner(), 0);
        }
        _burn(_user, _amount);
    }

    function getRewardRates() public view returns (TokenRewardRate[] memory) {
        return rewardRates;
    }

    function stakeRewardCal(
        uint256 _amt,
        uint256 _start,
        uint256 _end
    ) public view returns (uint256) {
        uint256 stakedDuration = (_end - _start) / 30 days; // divide 30 days
        require(stakedDuration > 0, \"Staked duration must be at least 1 month\");

        uint256 reward = 0;

        for (uint256 i = 0; i < rewardRates.length; i++) {
            if (stakedDuration >= rewardRates[i].months) {
                reward = (_amt * rewardRates[i].rewardRate) / 100;
            } else {
                break;
            }
        }

        return reward;
    }

    function allStakes(address _user) public view returns (StakeInfo[] memory) {
        uint256 length = nextStakeId[_user];
        uint256 activeCount = 0;

        // First, count the active stakes to size the array correctly
        for (uint256 i = 0; i < length; i++) {
            if (userStakes[_user][i].isActive) {
                activeCount++;
            }
        }

        StakeInfo[] memory tempStakes = new StakeInfo[](activeCount);
        uint256 index = 0;

        // Populate the tempStakes array with active stakes
        for (uint256 i = 0; i < length; i++) {
            if (userStakes[_user][i].isActive) {
                tempStakes[index] = userStakes[_user][i];
                index++;
            }
        }

        return tempStakes;
    }
}
"' \
--form 'constructorArguments="0000000000000000000000002ed3f15578bf85962fe960d8f7a82e409414ee0100000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000260000000000000000000000000000000000000000000000000000000000000002d000000000000000000000000000000000000000000000000000000000000004b000000000000000000000000000000000000000000000000000000000001518000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000463616b6500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000744ffd0001f411d781b6df6b828c76d32b65076e0000000000000000000000000000000000000000000000000000000000000008676f764e616d65310000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009676f7653796d626f6c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000744ffd0001f411d781b6df6b828c76d32b65076e00000000000000000000000000000000000000000000000000000000000001f400000000000000000000000010c01177b6f7dc0c31ede50aa38a91b74ce0f08100000000000000000000000000000000000000000000000000000000000000ca000000000000000000000000fe3b557e8fb62b89f4916b721be55ceb828dbd7300000000000000000000000000000000000000000000000000000000000000cb"' \
--form 'contractaddress="0x571423A8A906BeA68C29cA981363C3FdBF5D8D6f"' \
--form 'contractname="contracts/Verified.sol:Verified"' \
--form 'compilerversion="v0.8.28+commit.7893614a"' \
--form 'optimizationUsed="1"'
